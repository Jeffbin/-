/*
* 问题描述：尽量少的用6*6的盒子来装数量6*6，5*5，4*4，3*3，2*2，1*1的小盒子。
 *
* 提交状态： OLE
 *
* 交流结果： 内存：  时间：
 *
* 解题方法1：1.6*6，5*5，4*4，这几个规格的盒子就占用1个大盒子，每4个3*3的盒子就能装满一个大盒子，剩下1个的3*3的箱子，需要5个2*2的箱子填满，2个则要3个，
* 3个则需要1个2*2
2.然后计算用2*2的小盒子来补满以上的箱子需要多少个
* 如果2*2的盒子还有多的，就用另外的箱子装
* 3.计算补满以上的箱子需要多少1*1的箱子
* 如果1*1的还有多的，则用另外的箱子装
 *
* 解题方法2 （可选）：
*
* 出错次数：1
 *
* 错误原因 （可选）：在计算装3*3需要多少箱子的时候用了ab[2]/4+1的方法来向上取整，忽略了ab[2]为0 的情况，要用(ab[2]+3)/4的方法来取整
 *
* 心得体会 （可选）：
 */

#include <iostream>
using namespace std;
int a, b, c, d, e, f;


int main()
{
	int yong3[4] = { 0, 5, 3, 1 };
	int ab[6];
	cin >> ab[0] >> ab[1] >> ab[2] >> ab[3] >> ab[4] >> ab[5];
	while (ab[0] != 0 || ab[1] != 0 || ab[2] != 0 || ab[3] != 0 || ab[4] != 0 || ab[5] != 0)
	{
	
		int boxnum = 0;
		int box1=0;
		int box2=0;
		boxnum = ab[5]+ab[4]+ab[3]+(ab[2]+3)/4;//6*6+5*5+4*4+3*3
		box2 = 5 * ab[3] + yong3[ab[2] % 4];//计算要补满上面的箱子用多少2*2箱子
		if (ab[1] > box2)
		{
			boxnum += (ab[1] - box2+8) / 9 ;
		}
		box1 = boxnum * 36 - ab[5] * 36 - ab[4] * 25 - ab[3] * 16 - ab[2] * 9 - ab[1] * 4;//补满上面的箱子要用多少1*1的箱子
		if (ab[0] > box1)
		{
			boxnum += (ab[0] - box1+35) / 36 ;
		}
		cout << boxnum << endl;
		
		cin >> ab[0] >> ab[1] >> ab[2] >> ab[3] >> ab[4] >> ab[5];
	}

}
/*
Input:
0 0 4 0 0 1
7 5 1 0 0 0
36 9 4 1 1 1
0 9 4 1 1 0
0 0 4 0 0 0
36 0 0 0 0 0
0 9 0 0 0 0
79 96 94 30 18 14
53 17 12 98 76 54
83 44 47 42 80 3
15 26 13 29 42 40
41 61 36 90 54 66
78 56 445 45 23 65
13 4 8 29 45 3
15 75 45 98 34 53
40 9 0 2 0 0
41 9 0 2 0 0
44 0 0 0 4 0
0 2 3 0 0 0
37 7 2 0 1 0
12 2 0 1 0 0
13 2 0 1 0 0
0 0 0 0 0 0
Output:
2
1
6
4
1
1
1
86
231
137
115
219
245
79
197
3
4
4
2
3
1
2
*/

